/*
  从i站到达i+1站，如果能到达，继续往下走直至终点或者走不到，如果到达不了说明油量不够(从j-i+1出发，油量就会不够)，
  此时若出发站为j，则从j到i+1永远到不了，无论从j-i+1中的那一站出发，永远到不了i+1，
  所以此时需从i+1站开始出发，计算后面的站能否到达，若又遇上到达不了（m+1站），则继续从m+1站开始出发，
  一直判断到最后一站，得到一个最后的出发点（start，例如k+1），
  此时只要满足每个加油站的油量和大于耗费的油量和，那么最后一个出发点k+1就是答案。
  这种情况下，首先从k+1出发一定能到达最后一站且有剩余足够的油回到首站，并且回到首站（如j站）时还有富余，
  此时继续往下走一直走到i+1站，本来从j出发油量不够，但是现在从j出发有更多的油，且满足需求，所以可以走到i+1，且可以从i+1走到m+1，
  接着从m+1走到k+1。也就是回到出发点k+1,只要加油站的油量和大于耗费量和即可。
*/

int canCompleteCircuit(int* gas, int gasSize, int* cost, int costSize){
    int costSum = 0, gasSum = 0, start = 0;
    for(int i = 0; i < gasSize; i++){
        //计算i站到i+1站剩余的油量
        gasSum = gasSum + gas[i] - cost[i];
        //计算从0站到i+1站剩余的油量
        costSum = costSum + gas[i] - cost[i];
        //如果到i+1站油量小于0，则不能到达i+1站，从i+1站开始出发
        if(gasSum < 0){
            start = i + 1;
            gasSum = 0;   //从第i+1站重新开始计算油量
        }
    }
    if(costSum >= 0){
        return start;
    }
    else{
        return -1;
    }
}
